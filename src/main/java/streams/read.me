- using internal iteration, the Streams API can decide to run your code in
  parallel. Using external iteration, this isn’t possible because you’re committed to a
  single-threaded step-by-step sequential iteration.

- Note that limit also works on unordered streams (for example, if the source is a Set). In this case
  you shouldn’t assume any order on the result produced by limit.

- In a nutshell, the flatMap method lets you replace each value of a stream with another stream
  and then concatenates all the generated streams into a single stream.

- Some operations don’t need to process the whole stream to produce a result. For example, say
  you need to evaluate a large boolean expression chained with and operators. You need only find
  out that one expression is false to deduce that the whole expression will return false, no matter
  how long the expression is; there’s no need to evaluate the entire expression. This is what
  short-circuiting refers to.

- You may wonder why we have both findFirst and findAny. The answer is parallelism. Finding
  the first element is more constraining in parallel. If you don’t care about which element is
  returned, use findAny because it’s less constraining when using parallel streams.

- These queries
  can be classified as reduction operations (a stream is reduced to a value). In functional
  programming-language jargon, this is referred to as a fold because you can view this operation
  as repeatedly folding a long piece of paper (your stream) until it forms a small square, which is
  the result of the fold operation.

- list of operations page 139

- all together

- The Streams API lets you express complex data processing queries. Common stream operations are
  summarized in table 5.1.
- You can filter and slice a stream using the filter , distinct , skip , and limit methods.
- You can extract or transform elements of a stream using the map and flatMap methods.
- You can find elements in a stream using the findFirst and findAny methods. You can match a given
  predicate in a stream using the allMatch , noneMatch , and anyMatch methods.
- These methods make use of short-circuiting: a computation stops as soon as a result is found; there’s
  no need to process the whole stream.
- You can combine all elements of a stream iteratively to produce a result using the reduce method, for
  example, to calculate the sum or find the maximum of a stream.
- Some operations such as filter and map are stateless; they don’t store any state. Some operations
  such as reduce store state to calculate a value. Some operations such as sorted and distinct also
  store state because they need to buffer all the elements of a stream before returning a new stream.
  Such operations are called stateful operations.
- There are three primitive specializations of streams: IntStream , DoubleStream , and LongStream .
  Their operations are also specialized accordingly.
- Streams can be created not only from a collection but also from values, arrays, files, and specific
  methods such as iterate and generate .
- An infinite stream is a stream that has no fixed size.